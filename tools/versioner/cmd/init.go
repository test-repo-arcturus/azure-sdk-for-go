// Copyright 2018 Microsoft Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/Azure/azure-sdk-for-go/tools/internal/log"
	"github.com/Azure/azure-sdk-for-go/tools/internal/pkgs"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

func initCommand() *cobra.Command {
	init := &cobra.Command{
		Use:   "init <searching dir>",
		Short: "Initialize a package into go module with initial version",
		Long: `This tool will detect every possible service under the searching directory, 
and make them as module with initial version. 
The default version for new stable modules is v1.0.0 and for new preview modules is v0.0.0.
NOTE: This command is only used on local and only for initial release.
`,
		Args: cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			root := args[0]
			classicalFile := viper.GetString("classical")
			return ExecuteInit(root, classicalFile)
		},
	}
	// register flags
	flags := init.Flags()
	flags.StringP("classical", "c", "", "file for classical package list, these packages will be skipped")
	if err := viper.BindPFlag("classical", flags.Lookup("classical")); err != nil {
		log.Fatalf("failed to bind flag: %+v", err)
	}

	return init
}

const (
	initialVerGo = `package %s

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

// UserAgent returns the UserAgent string to use when sending http.Requests.
func UserAgent() string {
	return "Azure-SDK-For-Go/%s %s/%s"
}

// Version returns the semantic version (see http://semver.org) of the client.
func Version() string {
	return "%s"
}

// tag: %s
`

	initialGoMod = `module %s

%s
`

	goVersion = `go 1.13`
)

func ExecuteInit(r, classicalFile string) error {
	root, err := filepath.Abs(r)
	if err != nil {
		return fmt.Errorf("failed to get absolute path from '%s': %+v", r, err)
	}
	classicalPackages, err := loadClassicalPackages(classicalFile)
	if err != nil {
		return fmt.Errorf("failed to load classical packages: %+v", err)
	}
	ps, err := pkgs.GetPkgs(root)
	if err != nil {
		return fmt.Errorf("failed to get packages: %+v", err)
	}
	var errs []error
	for _, p := range ps {
		// test if this is a classical package
		_, classical := classicalPackages[p.Dest]
		if classical {
			log.Infof("Skipping classical package: %s", p.Dest)
			continue
		}
		path := filepath.Join(root, p.Dest)
		tagPrefix, err := getTagPrefix(path)
		if err != nil {
			return fmt.Errorf("failed to get tag prefix: %+v", err)
		}
		// get tag and ver
		startingVer := getStartingVer(p)
		tag := tagPrefix + "/" + startingVer
		ver := versionGoRegex.FindString(startingVer)
		if !classical {
			if err := createVersionFile(root, p, tag, ver); err != nil {
				errs = append(errs, err)
			}
		}
		if err := createGoModFile(root, p); err != nil {
			errs = append(errs, err)
		}
		log.Infof("Created module: %s", tag)
	}
	// handle errors
	if len(errs) == 0 {
		return nil
	}
	for _, err := range errs {
		log.Errorln(err.Error())
	}
	return fmt.Errorf("execution failed with %d errors", len(errs))
}

func createVersionFile(root string, p pkgs.Pkg, tag, ver string) error {
	verFilePath := filepath.Join(root, p.Dest, "version.go")
	apiVersion, err := p.GetAPIVersion()
	if err != nil {
		return fmt.Errorf("failed to get api version of package %s: %+v", p.Dest, err)
	}
	content := fmt.Sprintf(initialVerGo, p.Package.Name, ver, p.Package.Name, apiVersion, ver, tag)
	err = ioutil.WriteFile(verFilePath, []byte(content), 0755)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %+v", verFilePath, err)
	}
	return nil
}

func createGoModFile(root string, p pkgs.Pkg) error {
	modFilePath := filepath.Join(root, p.Dest, "go.mod")
	fullPath := filepath.Join(root, p.Dest)
	index := strings.Index(fullPath, "github.com")
	if index < 0 {
		return fmt.Errorf("failed to find github.com in filepath %s", fullPath)
	}
	importPath := strings.ReplaceAll(fullPath[index:], "\\", "/")
	content := fmt.Sprintf(initialGoMod, importPath, goVersion)
	err := ioutil.WriteFile(modFilePath, []byte(content), 0755)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %+v", modFilePath, err)
	}
	return nil
}

func getStartingVer(p pkgs.Pkg) string {
	if p.IsPreviewPackage() {
		return startingModVerPreview
	}
	return startingModVer
}

func loadClassicalPackages(exceptFile string) (map[string]bool, error) {
	result := make(map[string]bool)
	if exceptFile == "" {
		return result, nil
	}
	abs, err := filepath.Abs(exceptFile)
	if err != nil {
		return nil, err
	}
	file, err := os.Open(abs)
	defer file.Close()
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := scanner.Text()
		result[line] = true
	}
	return result, nil
}
